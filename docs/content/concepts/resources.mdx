---
title: Resources | Dagster
description: Resources enable you to separate graph logic from environment, and therefore make it easier to test and develop graphs in various environments.
---

# Resources

Resources are objects that are shared across the implementations of multiple [software-defined assets](/concepts/assets/software-defined-assets) and [ops](/concepts/ops-jobs-graphs/ops) and that can be plugged in after defining those ops and assets.

Resources typically model external components that assets and ops interact with. For example, a resource might be a connection to a data warehouse like Snowflake or a service like Slack.

So, why use resources?

- **Plug in different implementations in different environments** - If you have a heavy external dependency that you want to use in production, but avoid using in testing, you can accomplish this by providing different resources in each environment. Check out [Separating Business Logic from Environments](/concepts/testing#separating-business-logic-from-environments) for more info about this capability.
- **Share configuration across multiple ops or assets** - Resources are configurable and shared, so you can supply configuration in one place instead of configuring the ops and assets individually.
- **Share implementations across multiple ops or assets** - When multiple ops access the same external services, resources provide a standard way to structure your code to share the implementations.

---

## Relevant APIs

| Name                                             | Description                                                                                                                                                                                                                 |
| ------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <PyObject object="resource" decorator />         | The decorator used to define resources. The decorated function is called a `resource_fn`. The decorator returns a <PyObject object="ResourceDefinition" />.                                                                 |
| <PyObject object="ResourceDefinition" />         | Class for resource definitions. You almost never want to use initialize this class directly. Instead, you should use the <PyObject object="resource" decorator /> which returns a <PyObject object="ResourceDefinition" />. |
| <PyObject object="InitResourceContext"/>         | The context object provided to a resource during initialization. This object contains required resource, config, and other run information.                                                                                 |
| <PyObject object="build_init_resource_context"/> | Function for building an <PyObject object="InitResourceContext"/> outside of execution, intended to be used when testing a resource.                                                                                        |
| <PyObject object="build_resources"/>             | Function for initializing a set of resources outside of the context of a job's execution.                                                                                                                                   |
| <PyObject object="with_resources"/>              | Function for providing resources to software-defined assets and source assets.                                                                                                                                              |

---

## Defining a resource

To define a resource, extend the <PyObject object="Resource"/> class. Wrap a function that takes an `init_context` as the first parameter, which is an instance of <PyObject object="InitResourceContext"/>. From this function, return or yield the object that you would like to be available as a resource.

```python file=/concepts/resources/resources.py startafter=start_resource_example endbefore=end_resource_example
from dagster._config.structured_config import Resource


class ExternalCerealFetcher(Resource):
    def fetch_new_cereals(self, start_ts, end_ts):
        pass
```

---

## Using resources

- [With software-defined assets](#using-resources-with-software-defined-assets)
- [With ops](#using-resources-with-ops)

### Using resources with software-defined assets

- [Accessing resources](#accessing-resources-in-software-defined-assets)
- [Providing resources](#providing-resources-to-software-defined-assets)

#### Accessing resources in software-defined assets

Software-defined assets specify resource dependencies by annotating the resource as a parameter to the asset function. The asset function will be passed an instance of the resource when it is executed.

```python file=/concepts/resources/resources.py startafter=start_asset_use_resource endbefore=end_asset_use_resource
from dagster import asset


@asset
def asset_requires_resource(foo: FooResource):
    do_something_with_resource(foo)
```

#### Providing resources to software-defined assets

How resources are provided to assets depends on how you're organizing your code definitions in Dagster.

<TabGroup>
<TabItem name="Using Definitions (recommended)">

Resources can be provided to software-defined assets by passing them to a <PyObject object="Definitions" /> object. The resources provided to <PyObject object="Definitions" /> are automatically bound to the assets.

```python file=/concepts/resources/resources.py startafter=start_asset_provide_resource endbefore=end_asset_provide_resource
from dagster import Definitions


defs = Definitions(
    assets=[asset_requires_resource],
    resources={"foo": foo_resource},
)
```

When defining asset jobs (using <PyObject object="define_asset_job" />), you don't need to provide resources to the job directly. The job will make use of the resources provided to the assets.

</TabItem>
<TabItem name="Using @repository">

For those still using <PyObject object="repository" decorator /> to organize definitions, you have to use <PyObject object="with_resources" /> to provide resources to assets. This function takes in a sequence of assets and returns transformed versions of those assets with the provided resources specified.

```python file=/concepts/resources/resources.py startafter=start_asset_provide_resource_using_repository endbefore=end_asset_provide_resource_using_repository
from dagster import repository, with_resources


@repository
def repo():
    return [
        *with_resources(
            definitions=[asset_requires_resource],
            resource_defs={"foo": foo_resource},
        )
    ]
```

**Note**: The `with_resources` function returns a copy of each asset, bound to the provided resources. Attempting to load a module containing an asset redefined via `with_resources` in the outermost scope along with the original asset may result in an `"asset is defined multiple times"` error. In this case, you may need to place your `with_resources` call within a repository definition.

</TabItem>
</TabGroup>

---

### Using resources with ops

- [Accessing resources](#accessing-resources-in-ops)
- [Providing resources](#providing-resources-to-ops)

#### Accessing resources in ops

Like software-defined assets, ops specify resource dependencies by annotating the resource as a parameter to the op function. The op function will be passed an instance of the resource when it is executed.

```python file=/concepts/resources/resources.py startafter=start_op_with_resources_example endbefore=end_op_with_resources_example
from dagster import op

CREATE_TABLE_1_QUERY = "create table_1 as select * from table_0"


@op
def op_requires_resources(database: DatabaseResource):
    database.execute_query(CREATE_TABLE_1_QUERY)
```

#### Providing resources to ops

Jobs provide resources to the ops inside them. A job has a dictionary that maps resource keys to resource definitions. You can supply this dictionary to the `resource_defs` argument when using either of the ways to construct a job: <PyObject object="GraphDefinition" method="to_job" /> or <PyObject object="job" decorator />.

Supplying resources when using <PyObject object="GraphDefinition" method="to_job" /> is especially common, because you can build multiple jobs from the same graph that are distinguished by their different resources.

```python file=/concepts/resources/resources.py startafter=start_graph_example endbefore=end_graph_example
from dagster import graph


@graph
def do_database_stuff():
    op_requires_resources()


do_database_stuff_prod = do_database_stuff.to_job(resource_defs={"database": database_resource_a})
do_database_stuff_dev = do_database_stuff.to_job(resource_defs={"database": database_resource_b})
```

Supplying resources to the <PyObject object="job" decorator />, i.e. when there aren't multiple jobs for the same graph, is also useful. For example, if you want to use an off-the-shelf resource or supply configuration in one place instead of in every op.

```python file=/concepts/resources/resources.py startafter=start_job_example endbefore=end_job_example
from dagster import job


@job(resource_defs={"database": database_resource})
def do_database_stuff_job():
    op_requires_resources()
```

---

## Resource configuration

The attributes on a <PyObject object="Resource"  /> class act as its config schema, which allows you to customize behavior at runtime through run configuration.

For example, let's say we wanted to pass a connection string to our `DatabaseConnection` resource.

```python file=/concepts/resources/resources.py startafter=start_resource_config endbefore=end_resource_config
from dagster._config.structured_config import Resource


class DatabaseConnection(Resource):
    connection: str
```

---

## Testing resource initialization

You can test the initialization of a resource by constructing it manually. If your resource doesn't require any other resources, you can simply construct the resource class directly.

```python file=/concepts/resources/resources.py startafter=start_resource_testing endbefore=end_resource_testing
from dagster._config.structured_config import Resource


class MyResource(Resource):
    def get_value(self) -> str:
        return "foo"


def test_my_resource():
    assert MyResource().get_value() == "foo"
```

If your resource requires other resources, then you can pass them as constructor arguments.

```python file=/concepts/resources/resources.py startafter=start_resource_testing_with_context endbefore=end_resource_testing_with_context
from dagster._config.structured_config import Resource


class StringHolderResource(Resource):
    value: str


class MyResourceRequiresAnother(Resource):
    foo: StringHolderResource
    bar: str


def test_my_resource_with_context():
    resource = MyResourceRequiresAnother(foo=StringHolderResource("foo"), bar="bar")
    assert resource.foo.value == "foo"
    assert resource.bar == "bar"
```

---

## Resource-to-resource dependencies

Resources can depend upon other resources. Use the `required_resource_keys` parameter of the <PyObject object="resource" decorator/> decorator to specify which resources to depend upon. Access the required resources through the context object provided to the wrapped function.

```python file=/concepts/resources/resources.py startafter=start_resource_dep_example endbefore=end_resource_dep_example
from dagster._config.structured_config import Resource


class Credentials(Resource):
    username: str
    password: str


class Client(Resource):
    credentials: Credentials

    def request(self, endpoint: str):
        ...
```

Now, consider an op that will use the `client` resource:

```python file=/concepts/resources/resources.py startafter=start_resource_dep_op endbefore=end_resource_dep_op
from dagster import graph, op


@op
def get_newest_stories(client: Client):
    return client.request("/stories/new")
```

When we construct a job with our `client`-utilizing op, we specify the `client` resource to our <PyObject object="Definitions" /> object. This in turn depends on a constructed `Credentials` resource.

```python file=/concepts/resources/resources.py startafter=start_resource_dep_job endbefore=end_resource_dep_job
credentials = Credentials(username="foo", password="bar")


@job
def connect():
    get_newest_stories()


defs = Definitions(
    jobs=[connect],
    resources={
        "client": Client(credentials=credentials),
    },
)
```

If we instead would like the configuration for our credentials to be provided at runtime, we can use the `configure_at_launch()` method to defer the construction of the `Credentials` resource until runtime. In this case, we must also specify the `credentials` resource to our `Definitions` object so it will appear in the launchpad.

```python file=/concepts/resources/resources.py startafter=start_resource_dep_job_runtime endbefore=end_resource_dep_job_runtime
credentials = Credentials.configure_at_launch()


@job
def connect():
    get_newest_stories()


defs = Definitions(
    jobs=[connect],
    resources={
        "credentials": credentials,
        "client": Client(credentials=credentials),
    },
)
```

---

## See it in action

For more examples of resources, check out the following in our [Hacker News example](https://github.com/dagster-io/dagster/tree/master/examples/project_fully_featured):

- [Resource that fetches from the Hacker News API](https://github.com/dagster-io/dagster/blob/master/examples/project_fully_featured/project_fully_featured/resources/hn_resource.py)
- [Using a resource in an asset](https://github.com/dagster-io/dagster/blob/master/examples/project_fully_featured/project_fully_featured/assets/core/items.py)
